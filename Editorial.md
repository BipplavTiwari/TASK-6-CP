# Editorial

It is clear from the problem statement that we need to handle <a href="https://www.geeksforgeeks.org/range-minimum-query-for-static-array/">Range Minimum Queries</a> for a static array, so it is good to use <a href="https://brilliant.org/wiki/sparse-table/">Sparse table</a> to store our data as they answer RMQs in <a href="https://www.codecogs.com/eqnedit.php?latex=O(1)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?O(1)" title="O(1)" /></a> time after precomputation in <a href="https://www.codecogs.com/eqnedit.php?latex=O(n\log&space;n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?O(n\log&space;n)" title="O(n\log n)" /></a> time and <a href="https://www.codecogs.com/eqnedit.php?latex=O(n\log&space;n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?O(n\log&space;n)" title="O(n\log n)" /></a> space. Having stored our data properly, we now jump to the crux of the problem.

Notice that <a href="https://www.codecogs.com/eqnedit.php?latex=\mu^2(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mu^2(n)" title="\mu^2(n)" /></a> is an indicator fuction for the property of being square-free i.e, <a href="https://www.codecogs.com/eqnedit.php?latex=\mu^2(n)&space;=1" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mu^2(n)&space;=1" title="\mu^2(n) =1" /></a> if <a href="https://www.codecogs.com/eqnedit.php?latex=n" target="_blank"><img src="https://latex.codecogs.com/gif.latex?n" title="n" /></a> is square-free and <a href="https://www.codecogs.com/eqnedit.php?latex=\mu^2(n)=0" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mu^2(n)=0" title="\mu^2(n)=0" /></a> otherwise. <a href="https://www.codecogs.com/eqnedit.php?latex=\mu(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mu(n)" title="\mu(n)" /></a> ,of course, is the famous <a href="https://en.wikipedia.org/wiki/Möbius_function">Mobius function</a>.
Also the number of naturals number less than or equal to a number(say <a href="https://www.codecogs.com/eqnedit.php?latex=n" target="_blank"><img src="https://latex.codecogs.com/gif.latex?n" title="n" /></a>) is just <a href="https://www.codecogs.com/eqnedit.php?latex=\phi(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\phi(n)" title="\phi(n)" /></a> , the <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Totient function</a>.

Now it is easy to see that the E-value of <a href="https://www.codecogs.com/eqnedit.php?latex=n" target="_blank"><img src="https://latex.codecogs.com/gif.latex?n" title="n" /></a> is just <a href="https://www.codecogs.com/eqnedit.php?latex=\mu^2(n)&space;\phi^2(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mu^2(n)&space;\phi^2(n)" title="\mu^2(n) \phi^2(n)" /></a> and the E-sum is just <a href="https://www.codecogs.com/eqnedit.php?latex=f(n)=\sum_{d|n}&space;\mu^2(d)&space;\phi^2(d)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?f(n)=\sum_{d|n}&space;\mu^2(d)&space;\phi^2(d)" title="f(n)=\sum_{d|n} \mu^2(d) \phi^2(d)" /></a> .

Of course, computing everything naively will result in TLE, so we need to be a bit clever. Some of us may be triggered to somehow appeal to the <a href="https://en.wikipedia.org/wiki/Möbius_inversion_formula">Mobius inversion formula</a> but sadly its not too easy that way. But luckily a trivial observation can save us, all we need right now is just the observation that <a href="https://www.codecogs.com/eqnedit.php?latex=f(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?f(n)" title="f(n)" /></a> is multiplicative. Why? Because <a href="https://www.codecogs.com/eqnedit.php?latex=\mu^2(n)\phi^2(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mu^2(n)\phi^2(n)" title="\mu^2(n)\phi^2(n)" /></a> , being a product of mutiplicative functions, is multiplicative and <a href="https://www.codecogs.com/eqnedit.php?latex=f(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?f(n)" title="f(n)" /></a> is just the sum function of <a href="https://www.codecogs.com/eqnedit.php?latex=\mu^2(n)\phi^2(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mu^2(n)\phi^2(n)" title="\mu^2(n)\phi^2(n)" /></a> and hece is multiplicative. A proof of this fact can be found <a href="https://crypto.stanford.edu/pbc/notes/numbertheory/mult.html">here</a>. So the idea is clear now, to find <a href="https://www.codecogs.com/eqnedit.php?latex=f(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?f(n)" title="f(n)" /></a> we just need to prime factorize <a href="https://www.codecogs.com/eqnedit.php?latex=n" target="_blank"><img src="https://latex.codecogs.com/gif.latex?n" title="n" /></a>, if say <a href="https://www.codecogs.com/eqnedit.php?latex=n=p_1&space;^{k_1}&space;p_2^{k_2}...p_m^{k_m}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?n=p_1&space;^{k_1}&space;p_2^{k_2}...p_m^{k_m}" title="n=p_1 ^{k_1} p_2^{k_2}...p_m^{k_m}" /></a>  then <a href="https://www.codecogs.com/eqnedit.php?latex=f(n)=\prod&space;_{i=1}&space;^{m}&space;f(p_i^{k_i})" target="_blank"><img src="https://latex.codecogs.com/gif.latex?f(n)=\prod&space;_{i=1}&space;^{m}&space;f(p_i^{k_i})" title="f(n)=\prod _{i=1} ^{m} f(p_i^{k_i})" /></a> .

Now, <a href="https://www.codecogs.com/eqnedit.php?latex=f(p_i^{k_i})=\sum&space;_{d|p_i^{k_i}}\mu^2(d)\phi^2(d)=\sum&space;_{d&space;\in&space;\{1,p_i,p_i^2,..p_i^{k_i}\}}\mu^2(d)\phi^2(d)=(1&plus;(p_i&space;-1)^2)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?f(p_i^{k_i})=\sum&space;_{d|p_i^{k_i}}\mu^2(d)\phi^2(d)=\sum&space;_{d&space;\in&space;\{1,p_i,p_i^2,..p_i^{k_i}\}}\mu^2(d)\phi^2(d)=(1&plus;(p_i&space;-1)^2)" title="f(p_i^{k_i})=\sum _{d|p_i^{k_i}}\mu^2(d)\phi^2(d)=\sum _{d \in \{1,p_i,p_i^2,..p_i^{k_i}\}}\mu^2(d)\phi^2(d)=(1+(p_i -1)^2)" /></a> .

So, <a href="https://www.codecogs.com/eqnedit.php?latex=f(n)=\prod&space;_{i=1}&space;^{m}&space;(1&plus;(p_i&space;-1)^2)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?f(n)=\prod&space;_{i=1}&space;^{m}&space;(1&plus;(p_i&space;-1)^2)" title="f(n)=\prod _{i=1} ^{m} (1+(p_i -1)^2)" /></a> .

We are pretty much done. As a last bit of optimization save the value of <a href="https://www.codecogs.com/eqnedit.php?latex=f(n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?f(n)" title="f(n)" /></a> to save time in case the same <a href="https://www.codecogs.com/eqnedit.php?latex=n" target="_blank"><img src="https://latex.codecogs.com/gif.latex?n" title="n" /></a> turns up in the same or another test case.

#### Time complexity

The only precomutation innvolved are finding smallest prime factors on numbers which takes `O(MAX_N)` time using linear sieve. `(MAX_N=1000003)`

Now for each test case we take `O(nlogn)` time in creating the sparse table, `q*log(MAX(A))` time(in worst case) to find the E-sum for given queries (since prime factorization+computing answer for a number k takes `O(logk)` time).
So, time complexity per test case is `O(nlog(n) + q*log((MAX(A))` .
